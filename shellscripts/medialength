#!/usr/bin/env python3

"""Compute the duration of media files

\b
This caches the duration of media files in a cache directory, so that
subsequent runs are faster. If media files are modified, the cache is recomputed

MEDIA is a list of media files to compute the duration of
"""

import sys
import operator
from typing import Optional, Sequence, Literal, Union
from pathlib import Path

import click

Ms = Union[int, float]

DEBUG = False


def debug(message: str) -> None:
    if DEBUG:
        click.echo(f"DEBUG: {message}", err=True)


class MediaFile:
    def __init__(
        self,
        path: Path,
        cache_dir: Path,
    ) -> None:
        self.path = path
        self.cache_file = cache_dir / Path(*self.path.absolute().parts[1:])

    __slots__ = ("path", "cache_file")

    def __repr__(self) -> str:
        return f"MediaFile({self.path})"

    def __str__(self) -> str:
        return str(self.path)

    def mediainfo_duration(self) -> Ms:
        from pymediainfo import MediaInfo  # type: ignore[import]

        debug(f"parsing {self.path}")
        tracks = MediaInfo.parse(self.path).tracks
        debug(f"tracks: {tracks}")
        if len(tracks) == 0:
            raise ValueError(f"Could not parse duration for {self.path}")
        duration: int
        for track in tracks:
            if track.duration is not None:
                duration = track.duration
                break
        else:
            raise ValueError(f"Could not parse duration for {self.path}")
        debug(f"parsed duration: {duration}")
        return duration

    def ffprobe_duration(self) -> Ms:
        import shlex
        import subprocess
        import shutil

        if not shutil.which("ffprobe"):
            raise ValueError(
                "ffprobe not found, cannot parse duration (this is installed as part of ffmpeg)"
            )

        cmd: Sequence[str] = [
            "ffprobe",
            "-i",
            str(self.path.absolute()),
            *shlex.split("-show_entries format=duration -v quiet -of csv='p=0'"),
        ]
        debug(f"running command: {cmd}")
        try:
            buf = subprocess.check_output(cmd)
        except subprocess.CalledProcessError as e:
            debug(f"could not parse duration for {self.path}, recieved {e}")
            raise ValueError(f"Could not parse duration for {self.path}") from e
        output = buf.decode().strip()
        if output == "" or output == "N/A":
            debug(f"could not parse duration for {self.path}, recieved {output}")
            raise ValueError(f"Could not parse duration for {self.path}")
        duration = int(float(output) * 1000)
        debug(f"parsed duration: {duration}")
        return duration

    def parse_duration(self, lib: Literal["mediainfo", "ffprobe"]) -> Ms:
        if lib == "mediainfo":
            try:
                duration = self.mediainfo_duration()
            except ValueError:
                # fall back to ffprobe
                duration = self.ffprobe_duration()
        else:
            duration = self.ffprobe_duration()
        return duration

    def read_cached_duration(self) -> Ms:
        # assumes the cache file exists
        try:
            cached_dur = int(self.cache_file.read_text())
        except ValueError:
            raise ValueError(f"Could not parse duration for {self.path}")
        debug(f"cached duration: {cached_dur}")
        return cached_dur

    def write_cached_duration(self, duration: Ms) -> None:
        if not self.cache_file.parent.exists():
            self.cache_file.parent.mkdir(parents=True, exist_ok=True)
        debug(f"writing duration {duration} to {self.cache_file}")
        self.cache_file.write_text(str(duration))

    def cached_duration(self, lib: Literal["mediainfo", "ffprobe"]) -> Ms:
        cf = self.cache_file
        if not cf.exists():
            debug(f"cache file {cf} does not exist")
            # write to cache file
            duration = self.parse_duration(lib)
            self.write_cached_duration(duration)
            return duration

        cf_st = cf.stat()
        media_st = self.path.stat()
        # if the cache file is older than the media file, then it's stale, recompute
        if cf_st.st_mtime < media_st.st_mtime:
            debug(f"cache file {cf} is older than media file {self.path}, recomputing")
            cf.unlink()
            return self.cached_duration(lib)  # recurse

        debug("cache file is newer than media file, reading from cache file")
        # otherwise, read from the cache file
        return self.read_cached_duration()


def display_duration(
    ms: Ms,
    *,
    display: Literal["ms", "path", "s", "m", "human", "all"],
    path: Optional[Path],
) -> str:
    if display == "ms":
        return str(round(ms, 2))
    elif display == "path":
        assert path is not None, "path must be provided when display is path"
        return str(path)
    elif display == "s":
        return str(round(ms / 1000, 2))
    elif display == "m":
        return str(round(ms / 1000 / 60, 2))
    elif display == "human":
        # divmod to get hours, minutes, seconds
        m, s = divmod(ms / 1000, 60)
        h, m = divmod(m, 60)
        seconds = f"{s:.2f}".zfill(5)  # pad x.xx with zeros
        return f"{int(h):02d}:{int(m):02d}:{seconds}"
    elif display == "all":
        # recursive call
        assert path is not None, "path must be provided when display is all"
        return "|".join(
            [
                display_duration(ms, display=d, path=path)  # type: ignore[arg-type]
                for d in ("ms", "s", "m", "human", "path")
            ],
        )
    else:
        raise ValueError(f"Invalid display {display}")


@click.command(context_settings={"max_content_width": 120}, help=__doc__)
@click.option(
    "--cache-dir",
    type=click.Path(path_type=Path, dir_okay=True),
    default=Path("~/.cache/medialength"),
    show_default=True,
    help="Cache directory",
)
@click.option(
    "--lib",
    type=click.Choice(["mediainfo", "ffprobe"]),
    envvar="MEDIALENGTH_LIB",
    default="ffprobe",
    show_default=True,
    show_envvar=True,
    help="Library to use for parsing media files",
)
@click.option(
    "--cache/--no-cache",
    default=True,
    show_default=True,
    help="Enable/disable caching",
)
@click.option(
    "-o",
    "--operation",
    type=click.Choice(["sum", "max", "min", "avg"]),
    default=None,
    help="Operation to perform on the durations",
)
@click.option(
    "-d",
    "--display",
    type=click.Choice(["ms", "s", "m", "human", "path", "all"]),
    default="human",
    help="Display format for durations",
)
@click.option("--debug", "_debug", is_flag=True, help="Enable debug mode")
@click.argument(
    "MEDIA",
    type=click.Path(exists=True, path_type=Path, allow_dash=True),
    nargs=-1,
    required=True,
)
def main(
    media: Sequence[Path],
    operation: Optional[Literal["sum", "max", "min", "avg"]],
    cache_dir: Path,
    lib: Literal["mediainfo", "ffprobe"],
    display: Literal["ms", "s", "m", "human", "path", "all"],
    _debug: bool,
    cache: bool,
) -> None:
    global DEBUG
    cache_dir = Path(cache_dir).expanduser().absolute()
    cache_dir.mkdir(parents=True, exist_ok=True)
    if len(media) == 1 and str(media[0]) == "-":
        media = [Path(f) for f in sys.stdin.read().splitlines()]
        for m in media:
            if not m.exists():
                # raise click exception
                raise click.BadParameter(f"File {m} from STDIN does not exist")
    if len(media) == 0:
        click.echo("No media files specified", err=True)
        return
    if _debug:
        DEBUG = True
    media_files = [MediaFile(m, cache_dir) for m in media]
    durations_gen = (
        mf.cached_duration(lib) if cache else mf.parse_duration(lib)
        for mf in media_files
    )
    if operation is None:
        for i, d in enumerate(durations_gen):
            if display == "path":
                click.echo(media[i])
            else:
                click.echo(display_duration(d, display=display, path=media[i]))
        return

    durations = list(durations_gen)

    if operation == "sum":
        if display in ["path", "all"]:
            click.echo("Cannot display path for sum/all", err=True)
            raise SystemExit(1)
        click.echo(display_duration(sum(durations), display=display, path=None))
    elif operation == "avg":
        average = sum(durations) / len(media_files)
        if display_duration in ["path", "all"]:
            click.echo("Cannot display path/all for average", err=True)
            raise SystemExit(1)
        click.echo(display_duration(average, display=display, path=None))
    elif operation == "max":
        max_index = max(enumerate(durations), key=operator.itemgetter(1))[0]
        click.echo(
            display_duration(
                durations[max_index], display=display, path=media[max_index]
            )
        )
    elif operation == "min":
        min_index = min(enumerate(durations), key=operator.itemgetter(1))[0]
        click.echo(
            display_duration(
                durations[min_index], display=display, path=media[min_index]
            )
        )
    else:
        raise ValueError(f"Invalid operation {operation}")


if __name__ == "__main__":
    main(prog_name="medialength")
